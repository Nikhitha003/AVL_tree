<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AVL Tree Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f6f9;
            text-align: center;
        }

        h1 {
            color: #333;
        }

        .controls {
            margin: 20px;
        }

        input {
            padding: 8px;
            width: 120px;
        }

        button {
            padding: 8px 12px;
            margin: 5px;
            cursor: pointer;
        }

        canvas {
            background: #fff;
            border: 1px solid #ccc;
            margin-top: 20px;
        }
    </style>
</head>
<body>

<h1>AVL Tree Visualizer</h1>

<div class="controls">
    <input type="number" id="value" placeholder="Enter value">
    <button onclick="insertValue()">Insert</button>
    <button onclick="deleteValue()">Delete</button>
    <button onclick="clearTree()">Clear Tree</button>
</div>

<canvas id="treeCanvas" width="1000" height="500"></canvas>

<script>
    class Node {
        constructor(value) {
            this.value = value;
            this.left = null;
            this.right = null;
            this.height = 1;
        }
    }

    class AVLTree {
        getHeight(node) {
            return node ? node.height : 0;
        }

        getBalance(node) {
            return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0;
        }

        rotateRight(y) {
            let x = y.left;
            let T2 = x.right;

            x.right = y;
            y.left = T2;

            y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;
            x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;

            return x;
        }

        rotateLeft(x) {
            let y = x.right;
            let T2 = y.left;

            y.left = x;
            x.right = T2;

            x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;
            y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;

            return y;
        }

        insert(node, value) {
            if (!node) return new Node(value);

            if (value < node.value)
                node.left = this.insert(node.left, value);
            else if (value > node.value)
                node.right = this.insert(node.right, value);
            else
                return node;

            node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            let balance = this.getBalance(node);

            if (balance > 1 && value < node.left.value)
                return this.rotateRight(node);

            if (balance < -1 && value > node.right.value)
                return this.rotateLeft(node);

            if (balance > 1 && value > node.left.value) {
                node.left = this.rotateLeft(node.left);
                return this.rotateRight(node);
            }

            if (balance < -1 && value < node.right.value) {
                node.right = this.rotateRight(node.right);
                return this.rotateLeft(node);
            }

            return node;
        }

        minValueNode(node) {
            let current = node;
            while (current.left) current = current.left;
            return current;
        }

        delete(node, value) {
            if (!node) return node;

            if (value < node.value)
                node.left = this.delete(node.left, value);
            else if (value > node.value)
                node.right = this.delete(node.right, value);
            else {
                if (!node.left || !node.right) {
                    node = node.left ? node.left : node.right;
                } else {
                    let temp = this.minValueNode(node.right);
                    node.value = temp.value;
                    node.right = this.delete(node.right, temp.value);
                }
            }

            if (!node) return node;

            node.height = Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1;
            let balance = this.getBalance(node);

            if (balance > 1 && this.getBalance(node.left) >= 0)
                return this.rotateRight(node);

            if (balance > 1 && this.getBalance(node.left) < 0) {
                node.left = this.rotateLeft(node.left);
                return this.rotateRight(node);
            }

            if (balance < -1 && this.getBalance(node.right) <= 0)
                return this.rotateLeft(node);

            if (balance < -1 && this.getBalance(node.right) > 0) {
                node.right = this.rotateRight(node.right);
                return this.rotateLeft(node);
            }

            return node;
        }
    }

    const tree = new AVLTree();
    let root = null;

    const canvas = document.getElementById("treeCanvas");
    const ctx = canvas.getContext("2d");

    function insertValue() {
        const val = parseInt(document.getElementById("value").value);
        if (!isNaN(val)) {
            root = tree.insert(root, val);
            drawTree();
        }
    }

    function deleteValue() {
        const val = parseInt(document.getElementById("value").value);
        if (!isNaN(val)) {
            root = tree.delete(root, val);
            drawTree();
        }
    }

    // ðŸ”´ CLEAR TREE FUNCTION
    function clearTree() {
        root = null;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawTree() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawNode(root, canvas.width / 2, 40, canvas.width / 4);
    }

    function drawNode(node, x, y, gap) {
        if (!node) return;

        ctx.beginPath();
        ctx.arc(x, y, 20, 0, Math.PI * 2);
        ctx.fillStyle = "#4CAF50";
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(node.value, x, y);

        if (node.left) {
            drawLine(x, y, x - gap, y + 60);
            drawNode(node.left, x - gap, y + 60, gap / 2);
        }

        if (node.right) {
            drawLine(x, y, x + gap, y + 60);
            drawNode(node.right, x + gap, y + 60, gap / 2);
        }
    }

    function drawLine(x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1 + 20);
        ctx.lineTo(x2, y2 - 20);
        ctx.stroke();
    }
</script>

</body>
</html>
